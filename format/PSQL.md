# PostgreSQL Transpilation Standard (`KA:MO1:YAML1->PSQL1`)

TODO: Document:
- ForMany <-> HasOne: Unique constraint on junction keys to enforce cardinality (ie `uk_basic_basic_parents_basic_id_basic_parent_id`)
- Case autogenerated identifier for constraints is too long (ie. >63 characters). Ie table name abbreviations (ie. `uk_b_bp_b_id_bp_id`), or names with hash element on collisions
- Add prominent model enum field example (`Nationality` -> `nationality_id`)
- Entity relationships are not explicitly transpiled, as sql views are read-only and cannot enforce referential integrity constraints that already exist at the table level. Instead, the relationships should be used in query contexts and for reflection / documentation purposes.

## Overview

This document specifies how Morphe (`KA:MO1:YAML1`) models are transpiled into PostgreSQL database schemas. The `KA:MO1:YAML1->PSQL1` standard ensures consistent and predictable PostgreSQL schema generation across projects.

## Models

### Basic Model with Fields

Input (.mod file):

```yaml
name: Person
fields:
  ID:
    type: AutoIncrement
    attributes:
      - mandatory
  FirstName:
    type: String
  LastName:
    type: String
identifiers:
  primary: ID
  name:
    - FirstName
    - LastName
```

Output (PostgreSQL):

```sql
CREATE TABLE persons (
    id SERIAL PRIMARY KEY,
    first_name TEXT,
    last_name TEXT,
    CONSTRAINT uk_persons_name_first_name_last_name UNIQUE (first_name, last_name)
);
```

### Model with Enum Field

Input (.mod file):

```yaml
name: Person
fields:
  ID:
    type: AutoIncrement
  Name:
    type: String
  Nationality:
    type: Nationality
identifiers:
  primary: ID
```

Output (PostgreSQL):

```sql
CREATE TABLE persons (
    id SERIAL PRIMARY KEY,
    "name" TEXT,
    nationality_id INTEGER NOT NULL,
    CONSTRAINT fk_persons_nationality_id FOREIGN KEY (nationality_id)
      REFERENCES nationalities(id)
      ON DELETE CASCADE
);

CREATE INDEX idx_persons_nationality_id ON persons(nationality_id);
```

### HasOne Relationship

Input (.mod file):

```yaml
name: Person
fields:
  ID:
    type: AutoIncrement
  Name:
    type: String
identifiers:
  primary: ID
related:
  ContactInfo:
    type: HasOne
```

Output (PostgreSQL):

```sql
CREATE TABLE persons (
    id SERIAL PRIMARY KEY,
    "name" TEXT,
    contact_info_id INTEGER,
    CONSTRAINT fk_persons_contact_info_id FOREIGN KEY (contact_info_id)
      REFERENCES contact_infos(id)
      ON DELETE CASCADE
);

CREATE INDEX idx_persons_contact_info_id ON persons(contact_info_id);
```

### HasMany Relationship

Input (.mod file):

```yaml
name: Company
fields:
  ID:
    type: AutoIncrement
  Name:
    type: String
identifiers:
  primary: ID
related:
  Person:
    type: HasMany
```

Output (PostgreSQL):

```sql
CREATE TABLE companies (
    id SERIAL PRIMARY KEY,
    "name" TEXT
);

CREATE TABLE persons (
    id SERIAL PRIMARY KEY,
    "name" TEXT,
    company_id INTEGER,
    CONSTRAINT fk_person_company_id FOREIGN KEY (company_id)
      REFERENCES companies(id)
      ON DELETE CASCADE
);

CREATE INDEX idx_persons_company_id ON persons(company_id);
```

### ForOne Relationship

Input (.mod file):

```yaml
name: ContactInfo
fields:
  ID:
    type: AutoIncrement
  Email:
    type: String
identifiers:
  primary: ID
related:
  Person:
    type: ForOne
```

Output (PostgreSQL):

```sql
CREATE TABLE contact_infos (
    id SERIAL PRIMARY KEY,
    email TEXT,
    person_id INTEGER,
    CONSTRAINT fk_contact_info_person_id FOREIGN KEY (person_id)
      REFERENCES persons(id)
      ON DELETE CASCADE
);

CREATE INDEX idx_contact_infos_person_id ON contact_infos(person_id);
```

### ForMany Relationship

Input (.mod file):

```yaml
name: Tag
fields:
  ID:
    type: AutoIncrement
  Name:
    type: String
identifiers:
  primary: ID
related:
  Article:
    type: ForMany
```

Output (PostgreSQL):

```sql
CREATE TABLE tags (
    id SERIAL PRIMARY KEY,
    "name" TEXT
);

-- The ForMany relationship requires a junction table
CREATE TABLE article_tags (
    article_id INTEGER NOT NULL,
    tag_id INTEGER NOT NULL,
    PRIMARY KEY (article_id, tag_id),
    CONSTRAINT fk_article_tag_article_id FOREIGN KEY (article_id)
      REFERENCES articles(id)
      ON DELETE CASCADE,
    CONSTRAINT fk_article_tag_tag_id FOREIGN KEY (tag_id)
      REFERENCES tags(id)
      ON DELETE CASCADE
);

CREATE INDEX idx_article_tags_article_id ON article_tags(article_id);
CREATE INDEX idx_article_tags_tag_id ON article_tags(tag_id);
```

### Special Case: ForMany <-> HasOne

We enforce the `HasOne` cardinality in this special case by adding a unique constraint to the junction table keys.

```yaml
name: Tag
fields:
  ID:
    type: AutoIncrement
  Name:
    type: String
identifiers:
  primary: ID
related:
  Article:
    type: ForMany
```

Output (PostgreSQL):

```sql
CREATE TABLE tags (
    id SERIAL PRIMARY KEY,
    "name" TEXT
);

-- The ForMany relationship requires a junction table with a Unique constraint to enforce `HasOne` cardinality
CREATE TABLE article_tags (
    article_id INTEGER NOT NULL,
    tag_id INTEGER NOT NULL,
    -- Other constraints ...
    CONSTRAINT uk_article_tags_article_id UNIQUE (article_id)
);

-- Other indices ...
```


## Enumerations

In the `KA:MO1:YAML1->PSQL1` standard, enumerations are implemented exclusively as lookup tables for maximum flexibility.

Input (.enum file):

```yaml
name: Nationality
type: String
entries:
  US: 'American'
  DE: 'German'
  FR: 'French'
```

Output (PostgreSQL):

```sql
CREATE TABLE nationalities (
    id SERIAL PRIMARY KEY,
    key TEXT NOT NULL,
    value TEXT NOT NULL,
    CONSTRAINT uk_nationalities_key UNIQUE (key)
);

INSERT INTO nationalities (key, value) 
VALUES 
    ('US', 'American'),
    ('DE', 'German'),
    ('FR', 'French');
```

Benefits of lookup tables:
- Better extensibility (new values can be added without schema changes)
- Supports additional metadata (descriptions, display names, etc.)
- Enables internationalization
- Maintains referential integrity
- Simplified querying with JOIN operations

### Alternative Approaches

While PostgreSQL offers native enum types, the `KA:MO1:YAML1->PSQL1` standard deliberately avoids them:

```sql
-- NOT SUPPORTED in `KA:MO1:YAML1->PSQL1`
CREATE TYPE user_role AS ENUM ('ADMIN', 'EDITOR', 'VIEWER');
```

Reasons for not supporting native PostgreSQL enums:
- Limited extensibility (adding values requires ALTER TYPE statements)
- No support for additional metadata
- More complex to modify in production environments
- Less flexible for evolving applications
- Difficult to version control changes

Project forks may implement native enum support if their use case prioritizes:
- Performance optimization
- Simplified schema with fewer tables
- Constraints that truly never change

## Constraint Naming

The standard uses abbreviated table and column names in constraint identifiers to stay within PostgreSQL's 63-character limit.

This is only applied when the structured names exceed the 63-character limit, ie. names such as `fk_persons_nationality_id` are still supported.

### Naming Pattern
- `fk_[abbreviated_table]_[abbreviated_column]` for foreign keys
- `uk_[abbreviated_table]_[abbreviated_column]` for unique constraints
- `idx_[abbreviated_table]_[abbreviated_column]` for indices

### Abbreviation Rules
1. Use first letter of each word in table name
2. Use first letter of each word in column name
3. For collisions, append a hash of the full name

Examples:
- `persons` -> `p`
- `contact_infos` -> `c_i`
- `article_tags` -> `a_t`
- `first_name` -> `f_n`
- `last_name` -> `l_n`

### Example Constraint Names
```sql
CONSTRAINT fk_p_c_i_id

CONSTRAINT uk_p_n_f_n_l_n

CREATE INDEX idx_p_n_id
```

## Type Mappings

Morphe Type | PostgreSQL Type | Notes
------------|----------------|------
UUID | UUID | Requires `uuid-ossp` extension
AutoIncrement | SERIAL or BIGSERIAL | BIGSERIAL for larger datasets
String | TEXT | Unbounded length
Integer | INTEGER | 4 bytes, range -2147483648 to +2147483647
Float | DOUBLE PRECISION | 8 bytes, 15 decimal digits precision
Boolean | BOOLEAN | true/false/null
Time | TIMESTAMP WITH TIME ZONE | ISO 8601 format with timezone
Date | DATE | Calendar date (no time of day)
Protected | TEXT | Client-side encryption recommended
Sealed | TEXT | Store as hash, use crypt() function

## Structures

According to the Morphe specification, structures are explicitly defined as "standalone, reusable, non-persisted groupings of fields" that serve as DTOs (data-transfer-objects) in application code. The specification does not provide a mechanism for models or entities to reference structures, meaning structures have no direct representation in a persistence layer like PostgreSQL.

Input (.str file):

```yaml
name: Address
fields:
  Street:
    type: String
  HouseNr:
    type: String
  ZipCode:
    type: String
  City:
    type: String
```

Output (PostgreSQL):

```sql
-- No direct database representation
-- Structures exist only in application code
```

### Standard Optional Persistence

While structures remain conceptually non-persisted, `KA:MO1:YAML1->PSQL1` provides a standardized optional pattern for structure persistence using a single table with JSONB storage. This balances the conceptual separation with practical needs for caching and persistence.

```sql
-- Optional standard table for structure persistence
CREATE TABLE morphe_structures (
    id SERIAL PRIMARY KEY,
    "type" TEXT NOT NULL,
    "data" JSONB NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indices for efficient querying
CREATE INDEX idx_morphe_structures_type ON morphe_structures("type");
CREATE INDEX idx_morphe_structures_data ON morphe_structures USING GIN ("data");
```

Example of using the standard structures table:

```sql
-- Storing an Address structure
INSERT INTO morphe_structures ("type", "data")
VALUES (
    'Address',
    '{"street": "123 Main St", "houseNr": "4B", "zipCode": "10001", "city": "New York"}'
);

-- Querying Address structures
SELECT * FROM morphe_structures 
WHERE "type" = 'Address' 
AND "data"->>'city' = 'New York';
```

This approach provides:
- A standardized mechanism for structure persistence
- Flexibility for caching and retrieval
- Minimal impact on database schema complexity
- Clear separation from domain models
- Support for JSONB querying capabilities

### Implementation Notes

Since the core Morphe specification defines structures as non-persisted constructs, `KA:MO1:YAML1->PSQL1` maintains this as the default approach. The standardized structures table is provided as an optional pattern when persistence is required.

Application developers working with Morphe may choose to:

1. Use structures purely as in-memory DTOs in application code (default)
2. Utilize the standardized morphe_structures table when persistence is needed
3. Manually persist structure data as JSONB in model tables for specific use cases
4. Map structures to tables manually outside the Morphe transpilation process

Example of manually persisting structure data in a model table:

```sql
-- This is NOT part of the standard transpilation, but an application-level pattern
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    "type" TEXT,
    -- Manual persistence of Address structure as JSONB
    "address" JSONB
);
```

### Extension Considerations

This approach maintains alignment with the core specification by keeping structures conceptually non-persisted, while providing a pragmatic solution for real-world persistence needs. Future extensions to the Morphe specification might consider:

1. Adding a mechanism for models to contain fields of structure types
2. Defining formal persistence strategies for embedded structures
3. Establishing composition relationships between models and structures

Until such extensions are formalized, the standardized morphe_structures table offers a consistent approach that balances specification purity with practical implementation needs.

## Entities

Entities in Morphe are high-level business objects that represent aggregates or views of data. In PostgreSQL, they can be implemented as views:

Input (.ent file):

```yaml
name: PersonProfile
fields:
  ID:
    type: Person.ID
  FullName:
    type: Person.Name
  Email:
    type: Person.ContactInfo.Email
  CompanyName:
    type: Person.Company.Name
identifiers:
  primary: ID
```

Output (PostgreSQL):

```sql
CREATE VIEW person_profiles AS
SELECT 
    p.id,
    p.name AS full_name,
    ci.email,
    c.name AS company_name
FROM 
    persons p
LEFT JOIN 
    contact_infos ci ON p.id = ci.person_id
LEFT JOIN 
    companies c ON p.company_id = c.id;
```

## Type Mappings

Morphe Type | PostgreSQL Type | Notes
------------|----------------|------
UUID | UUID | Requires `uuid-ossp` extension
AutoIncrement | SERIAL or BIGSERIAL | BIGSERIAL for larger datasets
String | TEXT | Unbounded length
Integer | INTEGER | 4 bytes, range -2147483648 to +2147483647
Float | DOUBLE PRECISION | 8 bytes, 15 decimal digits precision
Boolean | BOOLEAN | true/false/null
Time | TIMESTAMP WITH TIME ZONE | ISO 8601 format with timezone
Date | DATE | Calendar date (no time of day)
Protected | TEXT | Client-side encryption recommended
Sealed | TEXT | Store as hash, use crypt() function

## Indices and Performance

For optimal PostgreSQL performance, the transpiler should automatically create indices for:

1. All primary keys (implicit)
2. All foreign keys
3. All fields used in unique constraints (implicit)
4. Fields commonly used in filtering (based on annotations)

Example:

```sql
-- Automatically created for performance
CREATE INDEX idx_persons_company_id ON persons(company_id);
CREATE INDEX idx_contact_infos_email ON contact_infos(email);
```

## Migration Support

The `KA:MO1:YAML1->PSQL1` standard includes support for generating schema migrations using tools like:

1. Native SQL migration files
2. Schema versioning tables
3. Integration with common migration tools (Flyway, Liquibase, etc.)

Example migration file:

```sql
-- V1__create_initial_schema.sql
CREATE TABLE persons (
    id SERIAL PRIMARY KEY,
    "name" TEXT
);

-- V2__add_email_to_persons.sql
ALTER TABLE persons ADD COLUMN email TEXT;
```

## Contributing

See the main [Morphe `KA:MO1` specification](https://github.com/kalo-build/morphe-spec) for contribution guidelines.

## License

This project is licensed under the MIT License. 
